# Monitor #

## 设计思路 ##

为了使逻辑层代码不至于耦合度过高，因此把基础服务和业务代码的实现进行区分，业务代码为springMVC构建的web程序，使用REST方式的URL进行请求。消息传输的方式是json，实现的功能还包括以下一些

---
* ### 业务逻辑处理前期 ###
	* #### [ 接口调用的统计 ](#接口调用的统计) ####
	* #### [ 访问的过滤 ](#访问的过滤) ####
	* #### [ 访问的拦截 ](#访问的拦截) ####
	* #### [ 访问用户的统计 ](#访问用户的统计) ####

* ### 业务逻辑 ###
	* #### [ 登录逻辑 ](#登录逻辑) ####
		* [ 登录成功 ](#登录成功)
		* [ 登录失败 ](#登录失败)
	* #### [ 页面逻辑 ](#页面逻辑) ####
		* [ 展示接口调用统计 ](#展示接口调用统计)
		* [ 展示访问用户的统计 ](#展示访问用户的统计)
---		

#### 接口调用的统计 ####

接口调用的统计是对接口生命周期中的多种情况进行模拟，由于一个请求的生命周期是这样的：`request-->过滤器链进入-->拦截器链进入-->处理逻辑-->拦截器链返回-->过滤器链返回-->response`,因此对接口的统计也分为几个部分
* 所有请求(所有经过 `request-->过滤器链` 的请求，只要是通过过滤器链的第一个过滤器都算)
* 所有合法的请求(所有经过 `request-->过滤器链进入-->拦截器链进入` 的请求，只要是通过特定的拦截器都算)
* 所有有效的请求(所有完整经过上述流程中的请求都算)

#### 访问的过滤 ####
访问的过滤不针对单个用户，而是针对访问的相关系统，包括访问的ip，访问的设备，这一步会设计相关的过滤策略(风险控制)，并且只对符合过滤策略的请求进行放行，但是过滤器如果这样设计有一些问题，因为过滤器是针对所有请求的，如果请求的量非常大，那么过滤器的处理时间过长将严重影响请求的处理性能，因此过滤器将只制定相应的风险控制的策略，具体的执行将在具体的处理逻辑中进行实施

#### 访问的拦截 ####
不是所有的访问都被允许，与访问过滤不同的是，访问的拦截是针对访问本身，或者说是与访问用户相关的，因此当访问的用户不符合拦截器制定的策略的时候，所有的不符合要求的用户均被否决

#### 访问用户的统计 ####
由于对用户的识别是在过滤器之后，正式处理请求之前进行的(因为在这一步才开始进行用户的确认，因此在拦截器中才做用户统计的相关工作)

```
访问频度统计由于是实时和高频的，对于数据的错误容忍度也相对较高,
因此不必采用实时进行数据库插入和更新的操作，我们可以使用缓存来进
行实时写入和更新，redis是一个不错的选择
```



#### 登录逻辑 ####
登录成功

登录失败

#### 页面逻辑 ####
展示接口调用统计

展示访问用户的统计
